<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC
   "-//W3C//DTD XHTML 1.0 Strict//EN"
   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">

   <head>
      <script src = "./javascript/Color.js"></script>
      <script src = "./javascript/Square.js"></script>
      <script src = "./javascript/Shape.js"></script>

      <script src = "./javascript/shapes/IShape.js"></script>
      <script src = "./javascript/shapes/JShape.js"></script>
      <script src = "./javascript/shapes/LShape.js"></script>
      <script src = "./javascript/shapes/OShape.js"></script>
      <script src = "./javascript/shapes/SShape.js"></script>
      <script src = "./javascript/shapes/TShape.js"></script>
      <script src = "./javascript/shapes/ZShape.js"></script>

      <script src = "./javascript/MoveShapeAction.js"></script>
      <script src = "./javascript/actions/MoveShapeLeftAction.js"></script>
      <script src = "./javascript/actions/MoveShapeRightAction.js"></script>
      <script src = "./javascript/actions/MoveShapeDownAction.js"></script>
      <script src = "./javascript/actions/MoveShapeClockwiseAction.js"></script>
   </head>

   <body>
      <svg xmlns="http://www.w3.org/2000/svg"></svg>

      <script type="text/javascript">
      <!--
// dimensions of board
var NUMBER_COLUMNS = 10;
var NUMBER_ROWS = 15;

var svg = document.body.getElementsByTagName("svg")[0];

svg.setAttribute("height", NUMBER_ROWS * 20);
svg.setAttribute("width", NUMBER_COLUMNS * 20);

// draw board grid
var board = new Array(NUMBER_ROWS);
var square;

for(var row = 0; row < board.length; row++) {
   board[row] = new Array(NUMBER_COLUMNS);

   for(var column = 0; column < board[row].length; column++) {
      square = new Square();
      square.setSize(Shape.SQUARE_SIZE);
      square.setColor(Color.NONE);

      square.setYCoordinate(row * Shape.SQUARE_SIZE);
      square.setXCoordinate(column * Shape.SQUARE_SIZE);

      board[row][column] = square;
      board[row][column].appendTo(svg);
   }
}

var colors = new Array();

colors[0] = Color.BLUE;
colors[1] = Color.CYAN;
colors[2] = Color.GREEN;
colors[3] = Color.MAGENTA;
colors[4] = Color.ORANGE;
colors[5] = Color.PINK;

var gameOver = false;

var shape = getRandomShape();
shape.setColor(colors[Math.floor(Math.random() * 5)]);
shape.appendTo(svg);

function getRandomShape() {
   // random number between 0 and 6
   var i = Math.floor(Math.random() * 6);

   var xOffset = 0;
   var yOffset = 0;
   var shape;

   if(i == 0) {
      shape = new IShape();

      // move shape 5-squares to the right
      xOffset = (5 * Shape.SQUARE_SIZE);

      // move shape 3-squares down
      yOffset = (3 * Shape.SQUARE_SIZE);
   }
   else if(i == 1) {
      shape = new JShape();

      xOffset = (4 * Shape.SQUARE_SIZE);
   }
   else if(i == 2) {
      shape = new LShape();

      xOffset = (5 * Shape.SQUARE_SIZE);
   }
   else if(i == 3) {
      shape = new OShape();

      xOffset = (4 * Shape.SQUARE_SIZE);
      yOffset = Shape.SQUARE_SIZE;
   }
   else if(i == 4) {
      shape = new SShape(); // can't move

      xOffset = (4 * Shape.SQUARE_SIZE);
      yOffset = Shape.SQUARE_SIZE;
   }
   else if(i == 5) {
      shape = new TShape();

      xOffset = (4 * Shape.SQUARE_SIZE);
      yOffset = Shape.SQUARE_SIZE;
   }
   else if(i == 6) {
      shape = new ZShape();

      xOffset = (5 * Shape.SQUARE_SIZE);
      yOffset = Shape.SQUARE_SIZE;
   }

   var squares = shape.getSquares();
   var row, column;

   // for each square in shape
   for(var i = 0; i < squares.length; i++) {
      squares[i].setXCoordinate(squares[i].getXCoordinate() + xOffset);
      squares[i].setYCoordinate(squares[i].getYCoordinate() + yOffset);

      column = (squares[i].getXCoordinate()/Shape.SQUARE_SIZE);
      row = (squares[i].getYCoordinate()/Shape.SQUARE_SIZE);

      if(board[row][column].getColor() != Color.NONE) {
         gameOver = true;
         window.clearInterval(interval);
      }
   }

   return shape;
}

document.onkeypress = onKeyPress;

var LEFT_ARROW_KEY = 37;
var RIGHT_ARROW_KEY = 39;
var UP_ARROW_KEY = 38;
var DOWN_ARROW_KEY = 40;
var SPACE_BAR = 32;
var P_KEY = 112;

var moveDown = new MoveShapeDownAction(board);
var moveLeft = new MoveShapeLeftAction(board);
var moveRight = new MoveShapeRightAction(board);
var moveClockwise = new MoveShapeClockwiseAction(board);

var paused = true;
var interval;

function onKeyPress(event) {
   var keyCode = (event.keyCode || event.charCode);

   // alert("keyCode = " + keyCode); // Keep for other keyCodes

   if((shape == undefined) || gameOver) {
      return;
   }

   if(paused) {
      // unpause game
      if(keyCode == P_KEY) {
         interval = window.setInterval(timedDrop, 500);
         paused = false;
      }
   }
   else {
      if((keyCode == SPACE_BAR) || (keyCode == DOWN_ARROW_KEY)) {
         moveDown.execute(shape);
      }
      else if(keyCode == LEFT_ARROW_KEY) {
         moveLeft.execute(shape);
      }
      else  if(keyCode == RIGHT_ARROW_KEY) {
         moveRight.execute(shape);
      }
      else if(keyCode == UP_ARROW_KEY) {
         moveClockwise.execute(shape);
      }
      else if(keyCode == P_KEY) {
         // pause game
         window.clearInterval(interval);
         paused = true;
      }
   }
}

var isHighlighted = false;

function timedDrop() {

   if(shape == undefined) {

      // if there are highlighted rows on the board
      if(isHighlighted) {
         // create a temporary board that's empty
         var tmpBoard = new Array(NUMBER_ROWS);

         for(var row = 0; row < board.length; row++) {
            tmpBoard[row] = new Array(NUMBER_COLUMNS);

            for(var column = 0; column < board[row].length; column++) {
                  tmpBoard[row][column] = Color.NONE;
            }
         }

         // fromRow corresponds to Tetris board
         var fromRow = NUMBER_ROWS - 1;

         // toRow corresponds to temporary board
         var toRow = fromRow;

         // while there are still more rows to process on board
         while(fromRow >= 0) {

            // copy row to temporary board if it is not highlighted
            if(Color.YELLOW != board[fromRow][0].getColor()) {

                        for (var column = 0; column < NUMBER_COLUMNS; column++) {
                  tmpBoard[toRow][column] = board[fromRow][column].getColor();
               }

               // move to next row up on temporary board
               toRow = toRow - 1;
            }

            // move to next row up on Tetris board
            fromRow = fromRow - 1;
         }

         // transfer colors from temporary board
         for(var row = 0; row < board.length; row++) {
            for(var column = 0; column < board[row].length; column++) {
                  board[row][column].setColor(tmpBoard[row][column]);
            }
         }

         isHighlighted = false;
      }

      // create a new shape
      shape = getRandomShape();
      shape.setColor(colors[Math.floor(Math.random() * 5)]);
      shape.appendTo(svg);
      return;
   }

   if(moveDown.isValidMove(shape)) {
      moveDown.move(shape);
   }
   else {
      // put shape on grid
      var squares = shape.getSquares();

      var row, column;
      var isCompleted;

      // for each square in shape
      for(var i = 0; i < squares.length; i++) {
         column = (squares[i].getXCoordinate()/Shape.SQUARE_SIZE);
         row = (squares[i].getYCoordinate()/Shape.SQUARE_SIZE);

         board[row][column].setColor(shape.getColor());

         // assume row is completed
         isCompleted = true;

         // test if row is not completed
         for(var c = 0; c < NUMBER_COLUMNS; c++) {
            if(Color.NONE == board[row][c].getColor()) {
               c = NUMBER_COLUMNS;
               isCompleted = false;
            }
         }

         // highlight row if it is completed
         if(isCompleted) {
            isHighlighted = true;

            for(var c = 0; c < NUMBER_COLUMNS; c++) {
               board[row][c].setColor(Color.YELLOW);
            }
         }
      }

      shape.detachFrom(svg);
      shape = undefined;
   }
}

// TODO: next piece window
// TODO: display user's score
// TODO: display instructions for how to play
// TODO: allow player to play again

      //-->
      </script>
   </body>
</html>
